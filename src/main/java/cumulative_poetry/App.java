/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package cumulative_poetry;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

interface Poetry{
  public String revealPoetry();
}

class PoetryTaleForDay implements Poetry{
  private CumulativePoetry getPoetryTale;

  PoetryTaleForDay(CumulativePoetry getPoetryTale){
      this.getPoetryTale = getPoetryTale;
  }

  public String revealPoetry(){
    final Integer dayValue = Integer.parseInt(this.getDayValue());
    if(this.checkDayWithinRange(dayValue)){
      return this.getPoetryTale.getPoetryForDay(dayValue);
    }
    return "Day value is outside the range";
  }

  public String getDayValue(){
    return this.getPoetryTale.operationList.get(1);
  }

  public Boolean checkDayWithinRange(Integer dayValue){
    if(dayValue > this.getPoetryTale.MIN_DAY_LIMIT &&  dayValue <= this.getPoetryTale.MAX_DAY_LIMIT){
      return true;
    }
    return false;
  }
}

class WholePoetry implements Poetry{
  private CumulativePoetry getPoetryTale;

  WholePoetry(CumulativePoetry getPoetryTale){
      this.getPoetryTale = getPoetryTale;
  }

  public String revealPoetry(){
    String wholePoem = IntStream.range(this.getPoetryTale.MIN_DAY_LIMIT, this.getPoetryTale.MAX_DAY_LIMIT)
    .mapToObj(dayValue -> {
      System.out.println(String.format("Day %d -", dayValue + 1));
      final String taleForDay = this.getPoetryTale.getPoetryForDay(dayValue + 1);
      System.out.println(taleForDay);
      return String.format("Day %d -", dayValue + 1).concat(taleForDay);
    }).collect(Collectors.joining());
    return wholePoem;
  }
}

class NotPoetryProblem implements Poetry{
  public String revealPoetry(){
    return "Please enter a specific operation";
  }
}

class CumulativePoetry{
  final int MIN_DAY_LIMIT;
  final int MAX_DAY_LIMIT;
  final String[] DAY;
  List<String> operationList;
  Poetry poetry;

  CumulativePoetry(String[] taleForDay, String[] arguments){
    this.MIN_DAY_LIMIT = 0;
    this.MAX_DAY_LIMIT = 12;
    this.DAY = taleForDay;
    this.operationList = Arrays.asList(arguments);
  }

  public String revealTaleForDay(int dayValue){
    return this.DAY[dayValue];
  }

  public String getPoetryForDay(int dayValue){
    String taleForDay = IntStream.range(this.MAX_DAY_LIMIT - dayValue, this.MAX_DAY_LIMIT)
    .mapToObj(day -> this.revealTaleForDay(day))
    .collect(Collectors.joining());
    return "This is".concat(taleForDay).concat(".");
  }

  public String getPoetryTale(){
    if(this.operationList.contains("--reveal-for-day")){
        poetry = new PoetryTaleForDay(this);
    }
    else if(this.operationList.contains("--recite")){
        poetry = new WholePoetry(this);
    }
    else{
        poetry = new NotPoetryProblem();
    }
    return poetry.revealPoetry();
  }
}

public class App{
  String[] taleForDay;
  String[] arguments;

  App(String[] args){
    taleForDay = new String[]{
      " the horse and the hound and the horn that belonged to",
      " the farmer sowing his corn that kept",
      " the rooster that crowed in the morn that woke",
      " the priest all shaven and shorn that married",
      " the man all tattered and torn that kissed",
      " the maiden all forlorn that milked",
      " that cow with the crumpled horn that tossed",
      " the dog that worried",
      " the cat that killed",
      " the rat that ate",
      " the malth that lay in",
      " the house that Jack built"
    };
    arguments = args;
  }

  public String getPoetryTale(){
    CumulativePoetry poetry = new CumulativePoetry(this.taleForDay, this.arguments);
    String finalPoetry = poetry.getPoetryTale();
    if(! Arrays.asList(this.arguments).contains("--recite")){
      System.out.println(finalPoetry);
    }
    return finalPoetry;
  }

  public static void main(String[] args) {
      App app = new App(args);
      String finalPoetry = app.getPoetryTale();
  }
}
